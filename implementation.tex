%!TEX root =  index.tex

\section{Implementation}

In this chapter, we are describing the implementation. All of the code can be found at \cite{Zeyer13Github}.

The code consists of several parts.
All of it was implemented around the Sage (\cite{sage}) framework, thus the main language is Python (\cite{python}).
For performance reasons, some very heavy calculations have been implemented in C++ (\cite{cpp}) and some Cython (\cite{cython}) code is the interface between both parts.

\subsection{Basic code structure}

\subsubsection{Main function \ifuncname{herm_modform_space}}
The main entry point is in the file \ifilename{algo.py}.
The function \ifuncname{herm_modform_space} calculates the Hermitian modula form space.
The function gets the fundamental discriminant \isymbname{D} $= - \Delta$, the Hermitian modula forms weight $k =$ \isymbname{HermWeight} and the precision limit $B_\F =$ \isymbname{B_cF} as its input and returns the vector space of Fourier expansions of Hermitian modular forms to the precision $B_\F$. The Fourier expansions are indexed by the reduced matrices of $\F$ (see \cref{remark:reducedCurlF} for details). This index list can also be returned by \ifuncname{herm_modform_indexset}.

The function can also do its calculation in parallel via multiple processes. As a convenience, to easily start the calculation with $N$ processes in parallel, there is the function \ifuncname{herm_modform_space__parallel} with the additional parameter \isymbname{task_limit}, where you just set \isymbname{task_limit} $=N$. For details about the parallelization, see \cref{impl:parallelization}.

Thus, to calculate the Hermitian modular forms with $D=-3$, weight $6$ and $B_\F = 7$, you can do:
\begin{lstlisting}
# run sage in the `src` directory of this work
import algo
algo.herm_modform_space(D=-3, HermWeight=6, B_cF=7)
\end{lstlisting}
Or, if you want to use 4 processes in parallel:
\begin{lstlisting}
algo.herm_modform_space__parallel(
    D=-3, HermWeight=6, B_cF=7, task_limit=4)
\end{lstlisting}

The function \ifuncname{herm_modform_space} uses \ifuncname{modform_restriction_info} and \ifuncname{modform_cusp_info} which are also defined in the same file.
The theory behind these functions is described in \cref{ellipticReduction} and \cref{cuspInfo}, accordingly.

Both return a vector space which is a superspace of the Hermitian modular form Fourier expansions and \ifuncname{herm_modform_space} intersects them until the final dimension is reached.

%---
\

In the rest of this chapter, we will demonstrate the details of the calculations and representations.


\subsection{$\curlO$ and $\curlO^\#$ representation and calculations}

To represent $\curlO$ and $\curlO^\#$ in code, mostly in the low level C++ code (files \ifilename{algo_cpp.cpp}, \ifilename{structs.hpp}, \ifilename{reduceGL.hpp}), we can use two integers in both cases as the coefficients of some basis.

Most of the calculations presented in this section are implemented in \ifilename{structs.hpp}.

\subsubsection{Representations}

%\paragraph{$\curlO$.}
\label{impl:repr:curlO}

For $a \in \curlO$, we use
\[ a = a_1 + a_2 \frac{D + \sqrt{D}} {2} \]
with $a_1,a_2 \in \Z$.
It holds
\begin{align*}
\Re(a) = &\; a_1 + a_2 \frac{D}{2} , \\
\Re(a)^2 =&\; a_1^2 + D a_1 a_2 + \frac{D^2}{4} a_2^2 , \\
\Im(a) =&\; a_2 \frac{\sqrt{-D}}{2} , \\
\Im(a)^2 =&\; a_2^2 \frac{-D}{4} , \\
|a|^2 =&\; \Re(a)^2 + \Im(a)^2 = a_1^2 - (-D) a_1 a_2 + \frac{D^2-D}{4} a_2^2 .
\end{align*}
Note that $4$ divides $D^2 - D$. Thus, $|a|^2 \in \Z$.

%4.5.13. b\in\curlO
Sometimes we have given $a \in \K$ where we easily have $\Re(a)$ and $\Im(a)$ available and we want to calculate $a_1, a_2 \in \Q$ in the above representation. We get
\begin{align*}
a_2 = &\; \Im(a) \frac{2}{\sqrt{-D}}, \\
a_1 = &\; \Re(a) - a_2 \frac{D}{2} = \Re(a) + \Im(a) \sqrt{-D} .
\end{align*}

%\paragraph{$\curlO^\#$.}
\label{impl:repr:curlOdual}

For $b \in \curlO^\#$, we use
\[ b = b_1 \frac{1}{\sqrt{D}} + b_2 \frac{1 + \sqrt{D}} {2} \]
with $b_1,b_2 \in \Z$.
% 6.6. alt det \cO^#
It holds
\begin{align*}
\Re(b) = &\; \frac{1}{2} b_2, \\
\Re(b)^2 = &\; \frac{1}{4} b_2^2, \\
\Im(b) = &\; -\frac{b_1}{\sqrt{-D}} + \frac{1}{2} \sqrt{-D} b_2, \\
\Im(b)^2 = &\; \frac{b_1^2}{-D} - b_1 b_2 + \frac{1}{4} (-D) b_2^2, \\
|b|^2 = &\; \Re(b)^2 + \Im(b)^2 = \frac{b_1^2}{-D} - b_1 b_2 + \frac{1}{4} (1-D) b_2^2 .
\end{align*}
When we need $|b|^2$ in an implementation, we can multiply it with $-D$ to get an integer:
\[ (-D) |b|^2 = b_1^2 - (-D) b_1 b_2 + \frac{D^2-D}{4} b_2^2 . \]
%
%4.5.13 b \in \curlO^#
%5.6.13 a \in \curlO^#
When we have $b \in \K$ where $\Re(b)$ and $\Im(b)$ are easily available and when we want to calculate $b_1,b_2 \in \Q$ in the above representation, we get
\begin{align*}
b_2 =&\; 2 \Re(b) , \\
b_1 =&\; b_2 \frac{-D}{2} - \Im(b) \sqrt{-D} = \Re(b) (-D) - \Im(b) \sqrt{-D} .
\end{align*}

%3.5.13 \curlO^# conjugate
Let us calculate the complex conjugate $\overline{b}$ of $b \in \curlO^\#$:
\begin{align*}
\overline{b} &= \frac{-b_1}{\sqrt{D}} + \frac{b_2}{2} - b_2 \frac{\sqrt{D}}{2} \\
&\overset{!}{=} \hat{b}_1 \frac{1}{\sqrt{D}} + \hat{b}_2 \frac{1 + \sqrt{D}} {2} \\
\Rightarrow \quad \hat{b}_2 &= b_2 , \\
\hat{b}_1 &= \overline{b} \sqrt{D} - \hat{b}_2 (\sqrt{D}+D) \tfrac{1}{2} \\
&= b_2 \frac{\sqrt{D}}{2} - b_2 \frac{\sqrt{D}}{2} - b_2 \frac{D}{2} - b_2 \frac{D}{2} - b_1 \\
&= -b_2 D - b_1 .
\end{align*}

%3.5.13 \curlO^# conjugate
Note that $b \in \R$ if and only if $b_1 \frac{1}{\sqrt{D}} = - b_2 \frac{\sqrt{D}}{2}$, i.e.
\[ 2 b_1 = - b_2 D . \]

\subsubsection{Multiplications}
\label{curlOmultiplications}
%3.5. ElemOfCurlO.mul()
Let $a,b \in \curlO$ with $a = a_1 + a_2 \frac{D + \sqrt{D}} {2}$, $b = b_1 + b_2 \frac{D + \sqrt{D}} {2}$. Then we have
\begin{align*}
a \cdot b &= a_1 b_1 + a_1 b_2 (D + \sqrt{D}) \tfrac{1}{2} + b_1 a_2 (D + \sqrt{D}) \tfrac{1}{2}
+ a_2 b_2 \tfrac{1}{4} \underbrace{(D^2 + 2 D \sqrt{D} + D)}_{= 2D (D + \sqrt{D}) - D^2 + D} \\
&= \frac{\sqrt{D} + D}{2} (a_1 b_2 + b_1 a_2 + D a_2 b_2)
+ a_1 b_1 - a_2 b_2 \frac{D^2 - D}{4} .
\end{align*}

%3.5.13 mult \curlO^# und \curlO
Now, let $a \in \curlO^\#$ and $b \in \curlO$ with
\begin{align*}
a &= a_1 \frac{1}{\sqrt{D}} + a_2 \frac{1 + \sqrt{D}} {2} , \\
b &= b_1 + b_2 \frac{D + \sqrt{D}} {2} .
\end{align*}
Then we have
\begin{align*}
a \cdot b &= a_1 b_1 \tfrac{1}{\sqrt{D}} + a_1 b_2 (\sqrt{D} + 1) \tfrac{1}{2}
+ a_2 b_1 (1 + \sqrt{D}) \tfrac{1}{2} + a_2 b_2
\underbrace{(D + \sqrt{D} + D \sqrt{D} + D)}_{
\begin{aligned}
= 2D + \sqrt{D} + D \sqrt{D} \\
= 2D + \sqrt{D} (1 + D)
\end{aligned}
}
\tfrac{1}{4} \\
&= a_1 b_1 \tfrac{1}{\sqrt{D}} + (a_1 b_2 + a_2 b_1) (1 + \sqrt{D}) \tfrac{1}{2}
+ a_2 b_2 (2D + \sqrt{D}(1 + D)) \tfrac{1}{4} .
\end{align*}
Thus, when representing $a \cdot b \in \curlO^\#$ as
\[ a \cdot b = (ab)_1 \frac{1}{\sqrt{D}} + (ab)_2 \frac{1 + \sqrt{D}} {2} , \]
we get
\[ (ab)_2 = a_1 b_2 + a_2 b_1 + a_2 b_2 D \]
and
\begin{align*}
(ab)_1 &= \sqrt{D} ab - (ab)_2 (\sqrt{D} + D) \tfrac{1}{2} \\
&= a_1 b_1 + (a_1 b_2 + b_1 a_2) (\sqrt{D} + D) \tfrac{1}{2} + a_2 b_2 (D + \sqrt{D})^2 \tfrac{1}{4} \\
&\quad - (a_1 b_2 + a_2 b_1 + a_2 b_2 D) (\sqrt{D} + D) \tfrac{1}{2} \\
&= a_1 b_1 + a_2 b_2 \underbrace{( (D+\sqrt{D})^2 \tfrac{1}{4} - D(\sqrt{D}+D)\tfrac{1}{2} )}_{
\begin{aligned}[l]
=& \tfrac{D^2}{4} + \tfrac{D\sqrt{D}}{2} + \tfrac{D}{4} - \tfrac{D\sqrt{D}}{2} - \tfrac{D^2}{2} \\
=& \tfrac{D^2 - D}{4}
\end{aligned}
} \\
&= a_1 b_1 + a_2 b_2 \frac{D^2 - D}{4} .
\end{align*}

\subsubsection{Determinant of 2-by-2 matrices}
\label{detCurlO}
%16.4.13 det(S)
For $[a,b,c] \in \Her_2(\C)$, we have
\[ \det([a,b,c]) = ac - b \overline{b} = ac - |b|^2 . \]
%
When we have $b \in \curlO$ or $b \in \curlO^\#$, we have given a formula for $|b|^2$ in \cref{impl:repr:curlO}. With those representations and $a,c \in \Z$, for $b \in \curlO$, we have
\[ \det([a,b,c]) = a c -  b_1^2 + (-D) b_1 b_2 - \tfrac{D^2-D}{4} b_2^2 \in \Z \]
and for $b \in \curlO^\#$, we have
\[ \det([a,b,c]) = a c - b_1^2 \tfrac{1}{-D} + b_1 b_2 - \tfrac{1}{4} (1-D) b_2^2 \in \tfrac{1}{-D} \Z . \]

In the code, we represent both matrices $\Her_2(\curlO)$ and $\Her_2(\curlO^\#)$ by 4-tuples $(a,b_1,b_2,c) \in \Z^4$.

\subsubsection{Trace of $TS$}
%16.4.13 tr(ST)
We want to calculate $\tr(TS)$ for $T \in \Her_2(\curlO^\#)$, $S \in \Her_2(\curlO)$.
Let $T = [T_a, T_b, T_c]$ and $S = [S_a, S_b, S_c]$ with
\begin{align*}
T_b &= T_{b1} \frac{1}{\sqrt{D}} + T_{b2} \frac{1 + \sqrt{D}} {2} , \\
S_b &= S_{b1} + S_{b2} \frac{D + \sqrt{D}} {2}
\end{align*}
and we have
\[ \overline{S_b} = S_{b1} + S_{b2} \frac{D - \sqrt{D}} {2} . \]
Then,
\[
\tr(T S) = T_a S_a
+ \underbrace{T_b \overline{S_b} + \overline{T_b} S_b}_{= 2 \Re(T_b \overline{S_b})}
+ T_c S_c
\]
and
\begin{align*}
\overline{S_b} T_b &= S_{b1} T_{b1} \tfrac{1}{\sqrt{D}} + S_{b1} T_{b2} (1 + \sqrt{D}) \tfrac{1}{2}
+ S_{b2} D \tfrac{1}{2} T_{b1} \tfrac{1}{\sqrt{D}}
- S_{b2} \tfrac{1}{2} T_{b1} \\
&\quad + T_{b2} S_{b2} \tfrac{1}{4} \underbrace{(D - \sqrt{D} + D \sqrt{D} - D)}_{=\sqrt{D}(D-1)} \\
\Rightarrow \Re(\overline{S_b} T_b) &= S_{b1} T_{b2} \tfrac{1}{2} - S_{b2} T_{b1} \tfrac{1}{2} .
\end{align*}
Thus, in our Computer implementation, we can just use
\[ \tr(T S) = T_a S_a + T_c S_c + S_{b1} T_{b2} - S_{b2} T_{b1} . \]
And if we have $T_a, T_{b1}, T_{b2}, T_{c}, S_a, S_{b1}, S_{b2}, S_c \in \Z$, we also have $\tr(TS) \in \Z$.


\subsection{Iteration of the precision Fourier indice $\F$}
\label{curlFiteration}

The set $\F$ depends on a limit $B_\F \in \N$:
\[ \F = \F_B = \Set{\SimpleMatrix{a}{b}{\overline b}{c} \in \Lambda}{0 \le a , c < B_{\F}} \subseteq \Lambda . \]
In \cref{remark:reducedCurlF}, we see that $\F$ is finite.

We have implemented an iteration of $\F$ in a way that the list of $\F_{B_2}$ always starts with $\F_{B_1}$ if $B_1 \le B_2$. That is \ifuncname{PrecisionF} in \ifilename{algo_cpp.cpp}. For testing and demonstration purpose, there is also a pure Python implementation \ifuncname{curlF_iter_py} in \ifilename{helpers.py}. I.e., in Python, for some $D$ and $B1 \le B2$, it yields:
\begin{lstlisting}
curlF1 = list(curlF_iter_py(D=D, B_cF=B1))
curlF2 = list(curlF_iter_py(D=D, B_cF=B2))
assert curlF1 == curlF2[:len(curlF1)]
\end{lstlisting}

The algorithm of the iteration of $T \in \F$ works in the following way: We have the current matrix represented as integers $a,b_1,b_2,c \in \Z$ and we start with each of them set to $0$. Then, $b = b_1 \frac{1}{\sqrt{D}} + b_2 \frac{1 + \sqrt{D}} {2}$ and $T = [a,b,c]$. We have the limit $B_\F \in \N_0$ and iterate an internal limit $\tilde{B} \in \Set{0,1,\dots,B_\F-1}$.
\begin{enumerate}
\item If the current saved matrix is a valid one, i.e. its determinant is not negative and $0 \le a,c \le B_\F$, we return it.
\item We iterate $b_2$ through $\Set{0,1,-1,2,-2,\dots}$.
\item
%23.5.13 \F iteration fix (\curlO^#). b_2
The absolut limit for $b_2$ is given by
\[ 4 a c \ge b_2^2 . \]
\begin{proof}
With $\det(T) \ge 0$, we have (see \cref{detCurlO})
\[ (-D) a c \ge b_1^2 - (-D) b_1 b_2 + \frac{(-D)(1-D)}{4} b_2^2 . \]
And it yields
\[ b_1^2 - (-D) b_1 b_2 = (b_1 - \tfrac{-D}{2} b_2)^2 - \tfrac{D^2}{4} b_2^2 \ge - \tfrac{D^2}{4} b_2^2 , \]
thus
\[ (-D) a c \ge - \tfrac{D^2}{4} b_2^2 + \frac{(-D)(1-D)}{4} b_2^2 = \tfrac{-D}{4} b_2^2 . \]
This is equivalent with the inequality to-be-proved.
\end{proof}
\item Once we hit that limit, we reset $b_2 := 0$ and we do one iteration step for $b_1$ through the set $\Set{0,1,-1,2,-2,\dots}$.
\item
%23.5.13 \F iteration fix (\curlO^#). nr2. b_1
The absolut limit for $b_1$ is given by
\[ a c (D^2 - D) \ge b_1^2 . \]
\begin{proof}
We have
\[ \tfrac{D^2-D}{4} b_2^2 - (-D) b_1 b_2
= \left( \sqrt{\tfrac{D^2-D}{4}} b_2 - \frac{-D}{2 \sqrt{\tfrac{D^2-D}{4}}} b_1 \right)^2
- \tfrac{(-D)^2}{D^2 - D} b_1^2
\ge - \tfrac{D^2}{D^2 - D} b_1^2 .
\]
Then, again with $\det(T) \ge 0$ like in the limit for $b_2$, we have
\[ (-D) a c \ge b_1^2 - \frac{D^2}{D^2 - D} b_1^2 = b_1^2 \frac{-D}{D^2-D} . \]
This is equivalent with the inequality to-be-proved.
\end{proof}
\item Once we hit that limit, we reset $b_1 := b_2 := 0$ and we increase $c$ by one.
\item Once we hit $c > \tilde{B}$, we reset $b_1 := b_2 := 0$ and we increase $a$ by one, if $a < \tilde{B}$. For all cases where $a < \tilde{B}$, we set $c := \tilde{B}$, otherwise $c := 0$.
\item Once we hit $a = \tilde{B}$, we increase $\tilde{B}$ by one and reset $a := 0$ and $c := \tilde{B}$.
\item Once we hit $\tilde{B} \ge B_\F$, we are finished.
\end{enumerate}

We have seen in \cref{reducedCurlF} that it is sufficient to use $\invarF{\F}{\GL_2(\curlO)}$ as the index set. In our implementation, we iterate through $\F$ and save the first occurrence of a new reduced matrix in a list. That list is returned by the function \ifuncname{herm_modform_indexset} which is declared in \ifilename{helpers.py}. It uses the C++ implementation in \ifilename{algo_cpp.cpp} as its backend. For testing and demonstration purpose, there is also a pure Python implementation \ifuncname{herm_modform_indexset_py} in \ifilename{helpers.py}.


\subsection{Iteration of $S \in \PM_2(\curlO)$}

The matrices $S \in \PM_2(\curlO)$ are used for the reduction in $f[S]$ for an Hermitian modula form $f$ as described in \cref{ellipticReduction}.

There are multiple implementations of this infinite iteration. Our first version only iterated through reduced matrices $\PM_2(\Z)$ with increasing determinator. We want the increasing determinant because we want to exhaust all possible matrices with low determinants because they are easier for the rest of the calculations. Later, it turned out that matrices only over $\Z$ don't yield enough information and we need matrices with imaginary components. Once you add the imaginary component, it is not possible anymore to iterate through all of $\PM_2(\Z)$ with increasing determinant because there can be infinity many matrices for a given determinant (or it is not trivial to see if there are not and how to set the limits in an implementation). Thus, the second implementation for matrices over $\PM_2(\curlO)$ does not keep the determinant fixed and rather works very similar to the iteration through $\F$, as described in \cref{curlFiteration}.

The implementation is in C++ in the file \ifilename{algo_cpp.cpp}. The class \isymbname{CurlS_Generator} owns and manages the iterator and can store several matrices at once because the main matrix calculation implementations (\cref{calcMatrix} and \cref{calcMatrixTrans}) can be done for several matrices at once. The class \isymbname{M2T_O_PosDefSortedZZ_Iterator} implements the iteration through $\PM_2(\Z)$ with increasing denominator. The class \isymbname{M2T_O_PosDefSortedGeneric_Iterator} implements the generic iteratoin through $\PM_2(\curlO)$.

The infinite iteration through $S \in \PM_2(\Z)$ in \isymbname{M2T_O_PosDefSortedZZ_Iterator} works as follows: We represent $S$ as $a,b,c \in \Z$ with $[a,b,c] = S$. We start with each of them set to zero. Also, we internally save the current determinant $\delta$ and start with $\delta := 0$.
\begin{enumerate}
\item We return a matrix if it is valid and reduced. That means that we only return if $a \le c$, $\det([a,b,c]) = ac - b^2 = \delta$ and if there is no common divisor of $a,b,c$ except $1$.
\item We increase $c$ by one. We set $a := \lfloor \frac{\delta + b^2}{c} \rfloor$.
\item Once we hit $c > \delta + b^2$, we reset $c := 0$ and make one iteration step for
$b \in \Set{0,1,-1,2,-2,\dots}$.
\item
Once we hit $3 b^2 > \delta$, we know that there aren't any further matrices with this determinant $\delta$. Thus we reset $a := b := c := 0$ and increase $\delta$ by one.
% 8.4.13 \S iteration
\begin{proof}
For a reduced matrix $[a,b,c]$, we have
\[ 0 \le 2 |b| \le a \le c . \]
Thus,
\[ \delta = ac - b^2 \ge (2 |b|) (2 |b|) - b^2 = 3 b^2 . \qedhere \]
\end{proof}
\end{enumerate}

The infinite iteration through $S \in \PM_2(\curlO)$ in \isymbname{M2T_O_PosDefSortedGeneric_Iterator} is mostly the same as the iteration of $\F$ as described in \cref{curlFiteration}. The difference is that $\F$ is over $\curlO^\#$ and $S$ is over $\curlO$. This yields to other limits for $b_1$ and $b_2$. Also, we don't have a limit like $\tilde{B}$.
\begin{enumerate}
\item We iterate $b_2$ through $\Set{0,1,-1,2,-2,\dots}$.
\item Once we hit the absolut limit of $b_2$, we reset $b_2 := 0$ and make one iteration step for $b_1 \in \Set{0,1,-1,2,-2,\dots}$.
\item Once we hit the absolut limit of $b_1$, we reset $b_1 := b_2 := 0$ and increase $c$ by one.
\item Once we hit $c > a$, we reset $c := b_1 := b_2 := 0$ and increase $a$ by one.
\end{enumerate}
%
%23.5.13 \S iteration fix (\curlO)
The absolut limit of $b_2$ is given by
\[ 4 ac \ge (-D) b_2^2 \]
and the absolut limit of $b_1$ is given by
\[ ac (1 - D) \ge b_1^2 . \]
\begin{proof}
We have $\det(S) \ge 0$ and thus
(see \cref{detCurlO})
\[ a c \ge b_1^2 - (-D) b_1 b_2 + \frac{D^2 - D}{4} b_2^2 . \]
Note that this is mostly like the inequality in the case over $\curlO^\#$, except that we have $ac$ on the left side instead of $(-D) ac$. Thus, we can mostly reuse the $b_1, b_2$ limit calculations from \cref{curlFiteration}. For $b_1$, we have
\[ a c \ge b_1^2 \frac{-D}{D^2-D} . \]
This is equivalent to the inequality to-be-proved.
And for $b_2$, we have
\[ a c \ge \tfrac{-D}{4} b_2^2 . \qedhere \]
\end{proof}


\subsection{\ifuncname{reduceGL}}
\label{impl:reduceGL}
In \cref{remark:reducedCurlF}, we have described that it is sufficient to use reduced matrices $\hat{T} \in \F$. Thus, in our implementation, for a given matrix $T \in \F$, we need a way to calculate the reduced matrix $\hat{T} \in \F$ such that
\[ \hat{T}[U_T] = T \]
for some $U_T \in \GL_2(\curlO)$. In the code, we don't need $U_T$ directly but rather the determinant of $U_T$.

Dominic Gehre and Martin Raum have developed a Cython implementation \cite{Raum09reduceGL} of "Functions for reduction of fourier indice of Hermitian modular forms". This function \ifuncname{reduceGL} gets a matrix $T \in \Her_2(\curlO^\#)$ and returns the Minkowski-reduced matrix $\hat{T} \in \Her_2(\curlO^\#)$ and some character evaluation of $U_T$ which also declares the determinant of $U_T$.

In this work, this function \ifuncname{reduceGL} has been reimplemented in C++ (\ifilename{reduceGL.hpp}) and in Python (\ifilename{reduceGL.py}).


\subsection{\ifuncname{divmod} and \ifuncname{xgcd}}

We have given numbers $a,b \in \curlO$ and we search for $d,p,q \in \curlO$ such that $d = pa + qb$ and $d$ divides $a$ and $b$. Then, $d$ is also the greatest common divisor (\ifuncname{gcd}). This is also equivalent to
\[ 1 = p \frac{a}{d} + q \frac{b}{d} . \]
%
For example, we need that in \ifuncname{solveR} (\cref{solveR}).

The extended Euclidean algorithm (\ifuncname{xgcd}) is the standard algorithm to calculate these numbers. It works over all Euclidean domains. In our case, it works for $\Delta \in \Set{1, 2, 3, 7, 11}$.

Sage has \ifuncname{xgcd} which works only for integers. It doesn't directly offer functions to calculate the \ifuncname{xgcd} over quadratic imaginary number fields.

Thus, in this work, we have reimplemented a simple canonical version of \ifuncname{xgcd} for $\curlO$ with a few fast paths, e.g. in the case of integers. This implementation can be found in the class \isymbname{CurlO} in \ifilename{helpers.py}.

The main work is done in the \ifuncname{divmod} function. \ifuncname{divmod} gets two numbers $a, b \in \curlO$ and returns $q, r \in \curlO$ such that $q b + r = a$. This is the division with remainder. It holds that $f(r) < f(b)$ for the Euclidean Norm $f \colon \K \rightarrow \R_{\ge 0}$. In our case, we have $f(x) = |x|$. The current implementation of \ifuncname{divmod} is very naive and should be improved. It can be found as well in the class \isymbname{CurlO} in \ifilename{helpers.py}.

Let $a,b \in \curlO$ with $q = \tfrac{a}{b}$ be represented in the base $(1, \frac{D + \sqrt{D}} {2})$ as described in \cref{impl:repr:curlO} as tuples $a_1,a_2,b_1,b_2 \in \Z$ and $q_1,q_2 \in \Q$. We can describe the equation $bq = a$ as a matrix multiplication
\[ \tilde{B} \begin{pmatrix} q_1 \\ q_2 \end{pmatrix} = \begin{pmatrix} a_1 \\ a_2 \end{pmatrix} . \]
With the inverse (if it exists), we can calculate $q$:
\[ \tilde{B}^{-1} \begin{pmatrix} a_1 \\ a_2 \end{pmatrix} = \begin{pmatrix} q_1 \\ q_2 \end{pmatrix} . \]
The multiplation formulas for $\curlO$ as described in \cref{curlOmultiplications} yield
\[ \tilde{B} = \begin{pmatrix}
b_1 & -b_2 \frac{D^2 - D}{4} \\
b_2 & b_1 + b_2 D
\end{pmatrix} . \]
Then, for the inverse, we have
\[ \tilde{B}^{-1} = \frac{1}{\det(\tilde{B})}
\begin{pmatrix}
b_1 + b_2 D & b_2 \frac{D^2 - D}{4} \\
-b_2 & b_1
\end{pmatrix} . \]
For the determinant, we have
\begin{align*}
\det(\tilde{B}) &= b_1^2 + b_1 b_2 D + b_2^2 \frac{D^2-D}{4} \\
&= (b_1 + b_2 \tfrac{D}{2})^2 \underbrace{- b_2^2 \tfrac{D^2}{4} + b_2^2 \tfrac{D^2-D}{4}}_{
= -b_2^2 \tfrac{D}{4} \ge 0} \ge 0.
\end{align*}
Note that $\det(\tilde{B}) = 0$ exactly if and only if $b_1 = b_2 = 0$, as it was expected.

This gives us some direct formulas for $q_1,q_2 \in \Q$ which are used in the \ifuncname{divmod} implementation where we select $q'_1, q'_2 \in \Z$ close to $q_1,q_2$ such that $r := a - q' b$ becomes minimal with regards to the Euclidean Norm.


\subsection{\ifuncname{solveR}}
\label{solveR}
\label{impl:solveR}

\subsection{Calculating the matrix of the map $a \rightarrow a[S]$}
\label{impl:calcMatrix}
\label{calcMatrix}
\label{calcMatrixTrans}


\subsection{Parallelization}
\label{impl:parallelization}
